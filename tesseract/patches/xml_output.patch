Index: tesseract-2.04/ccmain/baseapi.cpp
===================================================================
--- tesseract-2.04.orig/ccmain/baseapi.cpp
+++ tesseract-2.04/ccmain/baseapi.cpp
@@ -176,6 +176,30 @@ char* TessBaseAPI::TesseractRectBoxes(co
   return TesseractToBoxText(page_res, left, imageheight - (top + height));
 }
 
+// As TesseractRect but produces a box file as output.
+char* TessBaseAPI::TesseractRectXML(const unsigned char* imagedata,
+				    int bytes_per_pixel,
+				    int bytes_per_line,
+				    int left, int top,
+				    int width, int height)
+{
+  if (width < kMinRectSize || height < kMinRectSize)
+  return NULL;  // Nothing worth doing.
+
+  // Copy/Threshold the image to the tesseract global page_image.
+  CopyImageToTesseract(imagedata, bytes_per_pixel, bytes_per_line,
+                       left, top, width, height);
+
+  BLOCK_LIST    block_list;
+
+  FindLines(&block_list);
+
+  // Now run the main recognition.
+  PAGE_RES* page_res = Recognize(&block_list, NULL);
+
+  return TesseractToXML(page_res, width, height);
+}
+
 char* TessBaseAPI::TesseractRectUNLV(const unsigned char* imagedata,
                                      int bytes_per_pixel,
                                      int bytes_per_line,
@@ -502,6 +526,27 @@ int TessBaseAPI::TextLength(PAGE_RES* pa
   return total_length;
 }
 
+
+// Return the number of lines the output text string contains.
+int TessBaseAPI::TextLines(PAGE_RES* page_res) {
+  PAGE_RES_IT   page_res_it(page_res);
+  int nlines = 1;
+
+  // Iterate over the data structures to extract the recognition result.
+  for (page_res_it.restart_page(); page_res_it.word () != NULL;
+       page_res_it.forward()) {
+    WERD_RES *word = page_res_it.word();
+    WERD_CHOICE* choice = word->best_choice;
+    if (choice != NULL) {
+      if (word->word->flag(W_EOL))
+	nlines++;
+    }
+  }
+
+  return nlines;
+}
+
+
 // Returns an array of all word confidences, terminated by -1.
 int* TessBaseAPI::AllTextConfidences(PAGE_RES* page_res) {
   if (!page_res) return NULL;
@@ -647,6 +692,200 @@ char* TessBaseAPI::TesseractToBoxText(PA
 }
 
 // Make a text string from the internal data structures.
+// The input page_res is deleted. The text string is converted to XML.
+
+static char *ConvertWordToBoxXML(WERD_RES *word,
+				 ROW_RES* row,
+				 int imageheight,
+				 int *xx1, int *yy1, int *xx2, int *yy2,
+				 int *result_len)
+{
+  // Copy the output word and denormalize it back to image coords.
+  WERD copy_outword;
+  copy_outword = *(word->outword);
+  copy_outword.baseline_denormalise(&word->denorm);
+  PBLOB_IT blob_it;
+  blob_it.set_to_list(copy_outword.blob_list());
+  int length = copy_outword.blob_list()->length();
+  char *result = NULL;
+  int len = 0;
+
+  *xx1 = -1;
+  *yy1 = -1;
+  *xx2 = -1;
+  *yy2 = -1;
+
+  if (length > 0) {
+    int size = length * 50;
+    result = new char[size];
+
+    for (int index = 0, offset = 0; index < length;
+         offset += word->best_choice->lengths()[index++], blob_it.forward()) {
+      PBLOB* blob = blob_it.data();
+      TBOX blob_box = blob->bounding_box();
+      if (word->tess_failed ||
+          blob_box.left() < 0 ||
+          blob_box.right() > page_image.get_xsize() ||
+          blob_box.bottom() < 0 ||
+          blob_box.top() > page_image.get_ysize()) {
+        // Bounding boxes can be illegal when tess fails on a word.
+        blob_box = word->word->bounding_box();  // Use original word as backup.
+        tprintf("Using substitute bounding box at (%d,%d)->(%d,%d)\n",
+                blob_box.left(), blob_box.bottom(),
+                blob_box.right(), blob_box.top());
+      }
+
+      // A single classification unit can be composed of several UTF-8
+      // characters. Append each of them to the result.
+      char ch = word->best_choice->string()[offset];
+      // Tesseract uses space for recognition failure. Fix to a reject
+      // character, '~' so we don't create illegal box files.
+      if (ch == ' ')
+	ch = '~';
+
+      int x1 = blob_box.left();
+      int x2 = blob_box.right() + 1;
+      int y1 = imageheight - blob_box.top();
+      int y2 = imageheight - blob_box.bottom() + 1;
+
+      if ( (*xx1 < 0) || (x1 < *xx1) )
+	*xx1 = x1;
+      if ( x2 > *xx2 )
+	*xx2 = x2;
+      if ( (*yy1 < 0) || (y1 < *yy1) )
+	*yy1 = y1;
+      if ( y2 > *yy2 )
+	*yy2 = y2;
+
+      len += snprintf(result+len, size-len, "  <box geometry=\"%dx%d+%d+%d\" value=\"%c\" />\n",
+		      x2-x1, y2-y1, x1, y1, ch);
+    }
+  }
+
+  if ( result_len != NULL )
+    *result_len = len;
+
+  return result;
+}
+
+char* TessBaseAPI::TesseractToXML(PAGE_RES* page_res,
+				  int imagewidth, int imageheight)
+{
+  if (page_res != NULL) {
+    PAGE_RES_IT   page_res_it(page_res);
+
+    int nlines;
+    int size;
+    char *result;
+    int len;
+
+    size = TextLength(page_res) * 52; // <box /> <space />
+    size += TextLines(page_res) * 50; // <line> ... </line>
+    size += 20;                                // <page> ... </page>
+    //tprintf("-- result buffer size=%d\n", size);
+
+    result = new char[size];
+    len = sprintf(result, "<page>\n");
+
+    int line_x1 = -1;
+    int line_y1 = -1;
+    int line_x2 = -1;
+    int line_y2 = -1;
+    char *line_ptr = NULL;
+
+    int sp_x1 = -1;
+    int sp_y1 = -1;
+
+    for (page_res_it.restart_page(); page_res_it.word () != NULL;
+         page_res_it.forward()) {
+      WERD_RES *word = page_res_it.word();
+
+      int box_x1, box_y1;
+      int box_x2, box_y2;
+      int box_len;
+      char *box = ConvertWordToBoxXML(word, page_res_it.row(), imageheight,
+				      &box_x1, &box_y1, &box_x2, &box_y2,
+				      &box_len);
+      //tprintf("-- box_x1=%d box_y1=%d box_x2=%d box_y2=%d box_len=%d\n", box_x1, box_y1, box_x2, box_y2, box_len);
+
+      if ( box != NULL ) {
+	/* Update line geometry */
+	if ( (line_x1 < 0) || (box_x1 < line_x1) )
+	  line_x1 = box_x1;
+	if ( box_x2 > line_x2 )
+	  line_x2 = box_x2;
+	if ( (line_y1 < 0) || (box_y1 < line_y1) )
+	  line_y1 = box_y1;
+	if ( box_y2 > line_y2 )
+	  line_y2 = box_y2;
+
+	/* Dump a space element we are not at the begining of the line */
+	if ( (sp_x1 >= 0) && (sp_y1 >= 0) ) {
+	  int sp_x2 = box_x1;
+	  int sp_y2 = box_y2;
+
+	  if ( box_y1 < sp_y1 )
+	    sp_y1 = box_y1;
+	  //tprintf("   sp_x1=%d sp_y1=%d sp_x2=%d sp_y2=%d\n", sp_x1, sp_y1, sp_x2, sp_y2);
+
+	  if ( (sp_x2 > sp_x1) && (sp_y2 > sp_y1) ) {
+	    len += snprintf(result+len, size-len, "  <space geometry=\"%dx%d+%d+%d\" />\n",
+			    sp_x2-sp_x1, sp_y2-sp_y1, sp_x1, sp_y1);
+	  }
+	}
+	else {
+	  len += snprintf(result+len, size-len, " <line geometry=\"");
+	  line_ptr = result+len;
+	  len += snprintf(result+len, size-len, "                    >\n");
+	}
+
+	if ( (size-len) > box_len ) {
+	  strcpy(result+len, box);
+	  len += box_len;
+	}
+	else {
+	  break;
+	}
+
+	if  (word->word->flag(W_EOL) ) {
+	  if ( line_ptr != NULL ) {
+	    char buf[20+1];
+	    int n = snprintf(buf, sizeof(buf), "%dx%d+%d+%d\"",
+			     line_x2-line_x1, line_y2-line_y1, line_x1, line_y1);
+	    memcpy(line_ptr, buf, n);
+	  }
+
+	  len += snprintf(result+len, size-len, " </line>\n");
+
+	  sp_x1 = -1;
+	  sp_y1 = -1;
+	  line_x1 = -1;
+	  line_y1 = -1;
+	  line_x2 = -1;
+	  line_y2 = -1;
+	  line_ptr = NULL;
+	}
+	else {
+	  sp_x1 = box_x2;
+	  sp_y1 = box_y1;
+	}
+
+	delete [] box;
+      }
+    }
+
+    len += snprintf(result+len, size-len, "</page>\n");
+    //tprintf("-- result actual size=%d\n", len);
+
+    delete page_res;
+    return result;
+  }
+
+  return NULL;
+}
+
+
+// Make a text string from the internal data structures.
 // The input page_res is deleted. The text string is converted
 // to UNLV-format: Latin-1 with specific reject and suspect codes.
 const char kUnrecognized = '~';
Index: tesseract-2.04/ccmain/baseapi.h
===================================================================
--- tesseract-2.04.orig/ccmain/baseapi.h
+++ tesseract-2.04/ccmain/baseapi.h
@@ -108,6 +108,11 @@ class TessBaseAPI {
                                  int bytes_per_pixel,
                                  int bytes_per_line,
                                  int left, int top, int width, int height);
+  // As TesseractRect but produces XML output.
+  static char* TesseractRectXML(const unsigned char* imagedata,
+				int bytes_per_pixel,
+				int bytes_per_line,
+				int left, int top, int width, int height);
 
   // Call between pages or documents etc to free up memory and forget
   // adaptive data.
@@ -201,6 +206,8 @@ class TessBaseAPI {
 
   // Return the maximum length that the output text string might occupy.
   static int TextLength(PAGE_RES* page_res);
+  // Return the number of lines the output text string contains.
+  static int TextLines(PAGE_RES* page_res);
   // Returns the (average) confidence value between 0 and 100.
   // The input page_res is NOT deleted.
   static int TextConf(PAGE_RES* page_res);
@@ -217,6 +224,9 @@ class TessBaseAPI {
   // The input page_res is deleted. The text string is converted
   // to UNLV-format: Latin-1 with specific reject and suspect codes.
   static char* TesseractToUNLV(PAGE_RES* page_res);
+  // Make a text string from the internal data structures.
+  // The input page_res is deleted. The text string is converted to XML.
+  static char* TesseractToXML(PAGE_RES* page_res, int imagewidth, int imageheight);
 
   // __________________________   ocropus add-ons   ___________________________
 
Index: tesseract-2.04/ccmain/tesseractmain.cpp
===================================================================
--- tesseract-2.04.orig/ccmain/tesseractmain.cpp
+++ tesseract-2.04/ccmain/tesseractmain.cpp
@@ -57,6 +57,7 @@ void read_tiff_image(TIFF* tif, IMAGE* i
 #define API_CONFIG      "configs/api_config"
 #define EXTERN
 
+EXTERN BOOL_EVAR (xml_output, FALSE, "Output text in COSI-compliant XML format");
 EXTERN BOOL_VAR (tessedit_create_boxfile, FALSE, "Output text with boxes");
 EXTERN BOOL_VAR (tessedit_read_image, TRUE, "Ensure the image is read");
 EXTERN INT_VAR (tessedit_serial_unlv, 0,
@@ -94,6 +95,12 @@ void TesseractImage(const char* input_fi
                                             bytes_per_line, 0, 0,
                                             image->get_xsize(),
                                             image->get_ysize());
+    else if (xml_output)
+      text = TessBaseAPI::TesseractRectXML(image->get_buffer(),
+					   image->get_bpp()/8,
+					   bytes_per_line, 0, 0,
+					   image->get_xsize(),
+					   image->get_ysize());
     else
       text = TessBaseAPI::TesseractRect(image->get_buffer(), image->get_bpp()/8,
                                         bytes_per_line, 0, 0,
